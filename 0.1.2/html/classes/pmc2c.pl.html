<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>PMC compiler (Old Version)</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">PMC compiler (Old Version)</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../html/index.html">Contents</a> | <a href="../../html/pmc.html">PMCs</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="NAME"
>NAME <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>classes/pmc2c.pl &#45; PMC compiler (Old Version)</p>

<h1><a name="SYNOPSIS"
>SYNOPSIS <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p><b>This script has now been superceeded by <em lang='und' xml:lang='und'><a href="pmc2c2.pl.html">classes/pmc2c2.pl</a></em>.</b></p>

<pre lang='und' xml:lang='und'>    % perl pmc2c.pl [&#45;&#45;no&#45;lines] [&#45;&#45;tree] foo.pmc [foo2.pmc...]
    % perl pmc2c.pl B&#60;&#45;f&#62; method *.pmc</pre>

<p>The first class.pmc should be the name of the class you wish to create. Normally, the <em lang='und' xml:lang='und'>pmc2c.pl</em> translator uses <code lang='und' xml:lang='und'>#line</code> pragmas to tell the C compiler where each function in the .pmc file begins (line number). This allows the compiler to issue warnings and errors based on the .pmc file instead of on the .c file which should not be edited. However, there are times when this is not desirable and therefore the <code lang='und' xml:lang='und'>&#45;&#45;no&#45;lines</code> option is provided.</p>

<p>If <code lang='und' xml:lang='und'>&#45;&#45;tree</code> is set, the inheritance tree of given classes is printed, no further processing is done. The common base class &#39;default&#39; is not printed.</p>

<p>If <b>&#45;f</b> is set, the pmcs are printed, where this method is implemented.</p>

<h1><a name="DESCRIPTION"
>DESCRIPTION <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<p>The pmc2c program&#39;s job is to take .pmc files and create .c files which can be compiled for use with the Parrot interpreter.</p>

<p>First, the program determines the names of the .c and .h files from the basename of the .pmc file (e.g. perlint.pmc &#45;&#62; perlint.c and perlint.h). Next, the file is searched for /pmclass \w*/ which attempts to find the class being declared. Once the class is found, all of its superclasses are scanned and their methods added to the methods of the current PMC. PMCs default to inheriting from &#39;default&#39;. Only single inheritance is supported. Once the superclass is determined, it is processed and its method names are extracted and saved. Next, each method body is processed with various directives (see below) getting replaced by their appropriate values. Finally, the .c and .h files are generated. The appropriate base class header files are included. If the noinit flag was used, then no init function is generated, otherwise one is generated which sets up the vtable and enters it into the Parrot_base_vtables array. The .c file is generated by appending the functions after the various directives have been replaced.</p>

<h2><a name="PMC_File_Syntax"
>PMC File Syntax <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>The basic syntax of a PMC file is</p>

<ol>
<li>A preamble, consisting of code to be copied directly to the .c file</li><p class="pad"></p>

<li>The <code lang='und' xml:lang='und'>pmclass</code> declaration:</li><p class="pad"></p>

<pre lang='und' xml:lang='und'>        pmclass PMCNAME [extends PMCPARENT] [flags] {</pre>

<p>where <code lang='und' xml:lang='und'>flags</code> are:</p>

<dl>
<dt><a name="extends_PMCPARENT"
><b><code lang='und' xml:lang='und'>extends PMCPARENT</b></code></a></dt><p class="pad"></p>

<dd>All methods not defined in PMCNAME are inherited from the PMCPARENT class. If no parent class is defined, methods from <em lang='und' xml:lang='und'>default.pmc</em> are used.</dd><p class="pad"></p>

<dt><a name="abstract"
><b><code lang='und' xml:lang='und'>abstract</b></code></a></dt><p class="pad"></p>

<dd>This class can&#39;t be instantiated. Abstract classes are shown with lower case class names in the class tree.</dd><p class="pad"></p>

<dt><a name="noinit"
><b><code lang='und' xml:lang='und'>noinit</b></code></a></dt><p class="pad"></p>

<dd>Used with <code lang='und' xml:lang='und'>abstract</code>: No <code lang='und' xml:lang='und'>class_init</code> code is generated.</dd><p class="pad"></p>

<dt><a name="dynpmc"
><b><code lang='und' xml:lang='und'>dynpmc</b></code></a></dt><p class="pad"></p>

<dd>The class is a dynamic classes. These have a special <code lang='und' xml:lang='und'>class_init</code> routine suitable for dynamic loading at runtime. See the <em lang='und' xml:lang='und'>dynclasses</em> directory for an example.</dd><p class="pad"></p>

<dt><a name="const_too"
><b><code lang='und' xml:lang='und'>const_too</b></code></a></dt><p class="pad"></p>

<dd>Classes with this flag get 2 vtables and 2 enums, one with r/w set methods one with r/o set methods.</dd><p class="pad"></p>

<dt><a name="need_ext"
><b><code lang='und' xml:lang='und'>need_ext</b></code></a></dt><p class="pad"></p>

<dd>The class needs a <code lang='und' xml:lang='und'>PMC_EXT</code> structure (its using e.g. <code lang='und' xml:lang='und'>PMC_data</code>).</dd><p class="pad"></p>

<dt><a name="does_interface"
><b><code lang='und' xml:lang='und'>does interface</b></code></a></dt><p class="pad"></p>

<dd>The class does the given interfaces (the collection of methods which the class implements).</dd><p class="pad"></p>

<dd>The default is &#34;scalar&#34;. Other currently used interfaces are:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    array
    hash</pre>
</dl>

<li>A list of vtable method implementations</li><p class="pad"></p>

<li>The final close <code lang='und' xml:lang='und'>}</code></li><p class="pad"></p>
</ol>

<h2><a name="Method_Body_Substitutions"
>Method Body Substitutions <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<p>The vtable method bodies can use the following substitutions:</p>

<dl>
<dt><a name="SELF"
><b><code lang='und' xml:lang='und'>SELF</b></code></a></dt><p class="pad"></p>

<dd>Converted to the current PMC object of type <code lang='und' xml:lang='und'>PMC *</code>.</dd><p class="pad"></p>

<dt><a name="INTERP"
><b><code lang='und' xml:lang='und'>INTERP</b></code></a></dt><p class="pad"></p>

<dd>Converted to the interpreter object.</dd><p class="pad"></p>

<dt><a name="Otherclass.SELF.method(a,b,c)"
><b><code lang='und' xml:lang='und'>Otherclass.SELF.method(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>Calls the static vtable method &#39;method&#39; in <code lang='und' xml:lang='und'>OtherClass</code>.</dd><p class="pad"></p>

<dt><a name="SELF.method(a,b,c)"
><b><code lang='und' xml:lang='und'>SELF.method(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>Calls the vtable method &#39;method&#39; using the static type of <code lang='und' xml:lang='und'>SELF</code> (in other words, calls another method defined in the same file).</dd><p class="pad"></p>

<dt><a name="DYNSELF.method(a,b,c)"
><b><code lang='und' xml:lang='und'>DYNSELF.method(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>Calls the vtable method &#39;method&#39; using the dynamic type of <code lang='und' xml:lang='und'>SELF</code>.</dd><p class="pad"></p>

<dt><a name="DYNSELF(a,b,c)"
><b><code lang='und' xml:lang='und'>DYNSELF(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>Same as above, but calls the current method.</dd><p class="pad"></p>

<dt><a name="OtherClass.SUPER(a,b,c)"
><b><code lang='und' xml:lang='und'>OtherClass.SUPER(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>Calls the overridden implementation of the current method in <code lang='und' xml:lang='und'>OtherClass</code>.</dd><p class="pad"></p>

<dt><a name="SUPER(a,b,c)"
><b><code lang='und' xml:lang='und'>SUPER(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>Calls the overridden implementation of the current method in the nearest superclass, using the static type of <code lang='und' xml:lang='und'>SELF</code>.</dd><p class="pad"></p>

<dt><a name="DYNSUPER(a,b,c)"
><b><code lang='und' xml:lang='und'>DYNSUPER(a,b,c)</b></code></a></dt><p class="pad"></p>

<dd>As above, but uses the actual dynamic type of <code lang='und' xml:lang='und'>SELF</code>.</dd><p class="pad"></p>
</dl>

<h2><a name="Internal_Methods"
>Internal Methods <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h2>

<dl>
<dt><a name="extract_balanced($code)"
><b><code lang='und' xml:lang='und'>extract_balanced($code)</b></code></a></dt><p class="pad"></p>

<dd>This function&#39;s purpose is to extract the C code between the opening and closing brace of a function definition. For example, the function</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    void f( int x ) {
        if( x == 9 ) {
            printf( &#34;Hello!&#34; );
        }
        else {
            printf( &#34;Goodbye!&#34; );
        }
    }</pre>

<dd>would generate a return value of:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>    q{    if( x == 9 ) {
            printf( &#34;Hello!&#34; );
        }
        else {
            printf( &#34;Goodbye!&#34; );
        }
    }</pre>

<dd>It will actually return a triple consisting of the above, the passed in string with the above removed, and the current line number after the above has been removed.</dd><p class="pad"></p>

<dt><a name="parse_superpmc($data)"
><b><code lang='und' xml:lang='und'>parse_superpmc($data)</b></code></a></dt><p class="pad"></p>

<dd>This function looks for a superclass declaration in the current PMC class. If none was found, it assumes that default is the superclass. It then reads in the class definition for the superclass and remembers the method names. It returns an array ref to the method names and the name of the superclass that was analyzed.</dd><p class="pad"></p>

<dt><a name="superpmc_info($class)"
><b><code lang='und' xml:lang='und'>superpmc_info($class)</b></code></a></dt><p class="pad"></p>

<dd>This function opens the file containing the superclass reads in the data and calls <code lang='und' xml:lang='und'>parse_superpmc()</code>.</dd><p class="pad"></p>

<dt><a name="scan_inheritance_tree($classname)"
><b><code lang='und' xml:lang='und'>scan_inheritance_tree($classname)</b></code></a></dt><p class="pad"></p>

<dd>This function repeatedly calls <code lang='und' xml:lang='und'>superpmc_info()</code> passing in the current class name. <code lang='und' xml:lang='und'>superpmc_info()</code> will return a tuple containing all of the defined methods (not default) in that class as well as the name of the superclass that was processed. This function stops when the default superclass is processed. It returns a hash that maps the method name to the most derived class it was defined in.</dd><p class="pad"></p>

<dt><a name="count_newlines($string)"
><b><code lang='und' xml:lang='und'>count_newlines($string)</b></code></a></dt><p class="pad"></p>

<dd>Returns the number of newlines in <code lang='und' xml:lang='und'>$string</code>.</dd><p class="pad"></p>

<dt><a name="filter($contents,_$file,_$cfile)"
><b><code lang='und' xml:lang='und'>filter($contents, $file, $cfile)</b></code></a></dt><p class="pad"></p>

<dd>The <code lang='und' xml:lang='und'>filter()</code> function choreographs the previous functions actions on the pmcfile in question. It first scans the inheritance hierarchy to get all of the methods and their corresponding class of definition. Next, it skips over the extends clause and processes any flags (such as <code lang='und' xml:lang='und'>noinit</code>). Afterwards, it loops through each function declared and replaces directives with the appropriate values. Finally, it generates the .c and .h files for the .pmc file being analyzed.</dd><p class="pad"></p>
</dl>

<h1><a name="TODO"
>TODO <a href='#_top'><img alt='^' border=0 src='../../resources/up.gif'></a></a></h1>

<ul>
<li>Document the undocumented functions.</li><p class="pad"></p>
</ul>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
