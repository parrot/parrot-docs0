=head1 NAME

core.ops


=cut

=head1 DESCRIPTION

Parrot's core library of ops.


=cut

=head2 Basic ops

These are the fundamental operations.

=over 4


=cut

=item B<end>()

Halts the interpreter.


=cut

=item B<noop>()

Does nothing other than waste an iota of time and 32 bits of bytecode space.


=cut

=back


=cut

=head2 System environment operations

These operations allow interaction between the Parrot program and the system
environment.

=over 4


=cut

=item B<close>(inout INT)

Close file opened on file descriptor $1.


=cut

=item B<err>(out INT)

Store the system error code in $1.

=item B<err>(out STR)

Store the system error message in $1.


=cut

=item B<open>(out INT, in STR)

Open file named $2 for reading and writing and save the file
descriptor into $1.

=item B<open>(out INT, in STR, in STR)

Open file named $2 with flags $3 and mode 0644 (rw-r--r--), and save the file
descriptor into $1.


=cut

=item B<readline>(out STR, in INT)

Temporary hack op to read in a line from the file opened on the FILE *
we've evilly put in the integer register $2. If $2 is 0, 1, or 2 we
use stdin, stdout, or stderr respectively.

BE AFRAID! THIS IS *EEEEEEEVIL* pure and simple. (From the 8th
dimension, no less)

If for some reason the line's longer than 64K you get only 64K


=cut

=item B<ord>(out INT, in STR)

Two-argument form returns the 0th character of string $2 in register $1.
If $2 is empty, throws an exception.

=item B<ord>(out INT, in STR, in INT)

Three-argument form returns character $3 of string $2 in register $1.
If $2 is empty, throws an exception.
If $3 is greater than the length of string $2, throws an exception.
If $3 is less then zero but greater than the negative of the length, counts
backwards through the string, such that -1 is the last character, -2 is the
second-to-last character, and so on.
If $3 is less than the negative of the length, throws an exception.


=cut

=item B<print>(in INT)

=item B<print>(in NUM)

=item B<print>(in PMC)

=item B<print>(in STR)

Print $1 to standard output.

=item B<print>(in INT, in INT)

=item B<print>(in INT, in NUM)

=item B<print>(in INT, in STR)

=item B<print>(in INT, in PMC)

Print $2 to the file specified by file descriptor $1; for $1 equal to
0, 1 or 2, we use stdin, stdout or stderr respectively.


=cut

=item B<read>(out INT, in INT)

Read an INTVAL from file descriptor $2 into $1.

=item B<read>(out NUM, in INT)

Read a FLOATVAL from file descriptor $2 into $1.

=item B<read>(out STR, in INT, in INT)

Read $3 bytes from file descriptor $2 into string $1.


=cut

=item B<time>(out INT)

Puts the current system time (represented as a whole number of seconds)
in $1.


=cut

=item B<time>(out NUM)

Puts the current system time (represented as a number of seconds, with
microseconds) in $1.


=cut

=item B<write>(in INT, in INT)

=item B<write>(in INT, in NUM)

=item B<write>(in INT, in STR)

Write $2 to file descriptor $1.


=cut

=back


=cut

=head2 Register loading operations

These operations load registers from constants or other registers.

=over 4


=cut

=item B<clone>(out STR, in STR)

Make a clone of $2, and put it in $1. Doesn't affect what was in
$1. Removes the constant flag on the copy, if there was one.


=cut

=item B<set_addr>(out INT, in INT)

Sets register $1 to the current address plus the offset $2.


=cut

=item B<set>(out INT, in INT)

=item B<set>(out INT, in NUM)

=item B<set>(out INT, in PMC)

=item B<set>(out INT, in STR)

=item B<set>(out NUM, in INT)

=item B<set>(out NUM, in NUM)

=item B<set>(out NUM, in PMC)

=item B<set>(out NUM, in STR)

=item B<set>(out PMC, in INT)

=item B<set>(out PMC, in NUM)

=item B<set>(out PMC, in PMC)

=item B<set>(out PMC, in STR)

=item B<set>(out STR, in INT)

=item B<set>(out STR, in NUM)

=item B<set>(out STR, in PMC)

=item B<set>(out STR, in STR)

Set $1 to $2.


=cut

=item B<set>(out PMC, out PMC, in PMC, in PMC)

Set the entry of $1 accessed by $2 to the entry of $3 accessed by
$4, ie:

    $1[$2] = $3[$4];


=cut

=head2 Keyed set operations: Px[ Ix|KEY ] = Bx

=item B<set_keyed_integer>(out PMC, in INT, in INT)

=item B<set_keyed_integer>(out PMC, in INT, in NUM)

=item B<set_keyed_integer>(out PMC, in INT, in STR)

=item B<set_keyed_integer>(out PMC, in INT, in PMC)


=cut

=item B<set_keyed_integer>(out PMC, in KEY, in INT)

=item B<set_keyed_integer>(out PMC, in KEY, in NUM)

=item B<set_keyed_integer>(out PMC, in KEY, in STR)

=item B<set_keyed_integer>(out PMC, in KEY, in PMC)


=cut

=head2 Keyed set operations: Ax = Px[ Ix|KEY ]


=cut

=item B<set_keyed_integer>(out INT, in PMC, in INT)

=item B<set_keyed_integer>(out NUM, in PMC, in INT)

=item B<set_keyed_integer>(out STR, in PMC, in INT)

=item B<set_keyed_integer>(out PMC, in PMC, in INT)


=cut

=item B<set_keyed_integer>(out INT, in PMC, in KEY)

=item B<set_keyed_integer>(out NUM, in PMC, in KEY)

=item B<set_keyed_integer>(out STR, in PMC, in KEY)

=item B<set_keyed_integer>(out PMC, in PMC, in KEY)


=cut

=head2 Keyed set operations: Px[Sx] = Bx

=item B<set_keyed>(out PMC, in STR, in INT)

=item B<set_keyed>(out PMC, in STR, in NUM)

=item B<set_keyed>(out PMC, in STR, in STR)

=item B<set_keyed>(out PMC, in STR, in PMC)


=cut

=head2 Keyed set operations: Ax = Px[Sx]

=item B<set_keyed>(out INT, in PMC, in STR)

=item B<set_keyed>(out NUM, in PMC, in STR)

=item B<set_keyed>(out STR, in PMC, in STR)

=item B<set_keyed>(out PMC, in PMC, in STR)


=cut

=head2 Keyed set operations: Px[Nx] = Bx

=item B<set_keyed>(out PMC, in NUM, in INT)

=item B<set_keyed>(out PMC, in NUM, in NUM)

=item B<set_keyed>(out PMC, in NUM, in STR)

=item B<set_keyed>(out PMC, in NUM, in PMC)


=cut

=head2 Keyed set operations: Ax = Px[Nx]

=item B<set_keyed>(out INT, in PMC, in NUM)

=item B<set_keyed>(out NUM, in PMC, in NUM)

=item B<set_keyed>(out STR, in PMC, in NUM)

=item B<set_keyed>(out PMC, in PMC, in NUM)


=cut

=item B<clone>(out PMC, in PMC)

Copies a PMC $1 to $2.


=cut

=back


=cut

=head2 Conditional branch operations

These operations perform a conditional relative branch. If the condition is
met, the branch happens, otherwise control falls to the next operation.

=over 4


=cut

=item B<eq>(in INT, in INT)

=item B<eq>(in NUM, in NUM)

=item B<eq>(in STR, in STR)

=item B<eq>(in PMC, in PMC)

=item B<eq>(in INT, in INT, inconst INT)

=item B<eq>(in NUM, in NUM, inconst INT)

=item B<eq>(in STR, in STR, inconst INT)

=item B<eq>(in PMC, in PMC, inconst INT)

Branch if $1 is equal to $2.

Return address is popped off the call stack if no address is supplied.


=cut

=item B<ne>(in INT, in INT)

=item B<ne>(in NUM, in NUM)

=item B<ne>(in STR, in STR)

=item B<ne>(in PMC, in PMC)

=item B<ne>(in INT, in INT, inconst INT)

=item B<ne>(in NUM, in NUM, inconst INT)

=item B<ne>(in STR, in STR, inconst INT)

=item B<ne>(in PMC, in PMC, inconst INT)

Branch if $1 is not equal to $2.

Return address is popped off the call stack if no address is supplied.


=cut

=item B<lt>(in INT, in INT, inconst INT)

=item B<lt>(in NUM, in NUM, inconst INT)

=item B<lt>(in STR, in STR, inconst INT)

=item B<lt>(in PMC, in PMC, inconst INT)

Branch if $1 is less than $2.


=cut

=item B<le>(in INT, in INT, inconst INT)

=item B<le>(in NUM, in NUM, inconst INT)

=item B<le>(in STR, in STR, inconst INT)

=item B<le>(in PMC, in PMC, inconst INT)

Branch if $1 is less than or equal to $2.


=cut

=item B<gt>(in INT, in INT, inconst INT)

=item B<gt>(in NUM, in NUM, inconst INT)

=item B<gt>(in STR, in STR, inconst INT)

=item B<gt>(in PMC, in PMC, inconst INT)

Branch if $1 is greater than $2.


=cut

=item B<ge>(in INT, in INT, inconst INT)

=item B<ge>(in NUM, in NUM, inconst INT)

=item B<ge>(in STR, in STR, inconst INT)

=item B<ge>(in PMC, in PMC, inconst INT)

Branch if $1 is greater than or equal to $2.


=cut

=item B<if>(in INT, inconst INT)

=item B<if>(in NUM, inconst INT)

=item B<if>(in PMC, inconst INT)

=item B<if>(in STR, inconst INT)

Check register $1. If true, branch by $2.


=cut

=item B<unless>(in INT, inconst INT)

=item B<unless>(in NUM, inconst INT)

=item B<unless>(in PMC, inconst INT)

=item B<unless>(in STR, inconst INT)

Check register $1. If false, branch by $2.


=cut

=back


=cut

=head2 Arithmetic operations

These operations store the results of arithmetic on other registers and
constants into their destination register, $1.

=over 4


=cut

=item B<abs>(out INT, in INT)

=item B<abs>(out INT, in NUM)

=item B<abs>(out NUM, in INT)

=item B<abs>(out NUM, in NUM)

Set $1 to absolute value of $2.


=cut

=item B<add>(inout INT, in INT)

=item B<add>(inout NUM, in NUM)

=item B<add>(inout PMC, in INT)

=item B<add>(inout PMC, in NUM)

=item B<add>(inout PMC, in PMC)

Increase $1 by the amount in $2.

=item B<add>(out INT, in INT, in INT)

=item B<add>(out NUM, in NUM, in NUM)

=item B<add>(out PMC, in PMC, in INT)

=item B<add>(out PMC, in PMC, in PMC)

Set $1 to the sum of $2 and $3.


=cut

=item B<cmod>(out INT, in INT, in INT)

NOTE: This "uncorrected mod" algorithm uses the C language's built-in
mod operator (x % y), which is

    ... the remainder when x is divided by y, and thus is zero
    when y divides x exactly.
    ...
    The direction of truncation for / and the sign of the result
    for % are machine-dependent for negative operands, as is the
    action taken on overflow or underflow.
                                                     -- [1], page 41

Also:

    ... if the second operand is 0, the result is undefined. 
    Otherwise, it is always true that (a/b)*b + a%b is equal to z. If
    both operands are non-negative, then the remainder is non-
    negative and smaller than the divisor; if not, it is guaranteed
    only that the absolute value of the remainder is smaller than
    the absolute value of the divisor.
                                                     -- [1], page 205

This op is provided for those who need it (such as speed-sensitive
applications with heavy use of mod, but using it only with positive
arguments), but a more mathematically useful mod based on ** floor(x/y)
and defined with y == 0 is provided by the mod op.

  [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
      Language*, Second Edition. Prentice Hall, 1988.

TODO: Doesn't the Parrot interpreter need to catch the exception?


=cut

=item B<cmod>(out NUM, in NUM, in NUM)

NOTE: This "uncorrected mod" algorithm uses the built-in C math library's
fmod() function, which computes

    ... the remainder of dividing x by y. The return value is
    x - n * y, where n is the quotient of x / y, rounded towards
    zero to an integer.
                                -- fmod() manpage on RedHat Linux 7.0

In addition, fmod() returns

    the remainder, unless y is zero, when the function fails and
    errno is set.

According to page 251 of [1], the result when y is zero is implementation-
defined.

This op is provided for those who need it, but a more mathematically
useful numeric mod based on floor(x/y) instead of truncate(x/y) and
defined with y == 0 is provided by the mod op.

  [1] Brian W. Kernighan and Dennis M. Ritchie, *The C Programming
      Language*, Second Edition. Prentice Hall, 1988.

TODO: Doesn't the Parrot interpreter need to catch the exception?


=cut

=item B<dec>(inout INT)

=item B<dec>(inout NUM)

=item B<dec>(inout PMC)

Decrease $1 by one.


=cut

=item B<div>(out INT, in INT, in INT)

=item B<div>(out NUM, in NUM, in NUM)

=item B<div>(out PMC, in PMC, in PMC)

Set $1 to the quotient of $2 divided by $3. In the case of INTVAL division, the
result is truncated (NOT rounded or floored).


=cut

=item B<inc>(inout INT)

=item B<inc>(inout NUM)

=item B<inc>(inout PMC)

Increase $1 by one.


=cut

=item B<mod>(out INT, in INT, in INT)

NOTE: This "corrected mod" algorithm is based on the C code on page 70
of [1]. Assuming correct behavior of the built-in mod operator (%) with
positive arguments, this algorithm implements a mathematically convenient
version of mod, defined thus:

  x mod y = x - y * floor(x / y)

For more information on this definition of mod, see section 3.4 of [2],
pages 81-85.

References:

  [1] Donald E. Knuth, *MMIXware: A RISC Computer for the Third
      Millennium* Springer, 1999.

  [2] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
      Mathematics*, Second Edition. Addison-Wesley, 1994.

=item B<mod>(out PMC, in PMC, in PMC)

Sets $1 to the modulus of $2 and $3.


=cut

=item B<mod>(out NUM, in NUM, in NUM)

NOTE: This "corrected mod" algorithm is based on the formula of [1]:

  x mod y = x - y * floor(x / y)

For more information on this definition of mod, see section 3.4 of [1],
pages 81-85.

References:

  [1] Ronald L. Graham, Donald E. Knuth and Oren Patashnik, *Concrete
      Mathematics*, Second Edition. Addison-Wesley, 1994.


=cut

=item B<mul>(inout INT, in INT)

=item B<mul>(inout NUM, in NUM)

=item B<mul>(inout PMC, in PMC)

Set $1 to the product of $1 and $2.

=item B<mul>(out INT, in INT, in INT)

=item B<mul>(out NUM, in NUM, in NUM)

=item B<mul>(out PMC, in PMC, in PMC)

Set $1 to the product of $2 and $3.


=cut

=item B<neg>(inout INT)

=item B<neg>(inout NUM)

Set $1 to it's negative.

=item B<neg>(out INT, in INT)

=item B<neg>(out NUM, in NUM)

=item B<neg>(out PMC, in PMC)

Set $1 to the negative of $2.


=cut

=item B<pow>(out NUM, in INT, in INT)

=item B<pow>(out NUM, in INT, in NUM)

=item B<pow>(out NUM, in NUM, in INT)

=item B<pow>(out NUM, in NUM, in NUM)

Set $1 to $2 raised to the power $3.


=cut

=item B<sub>(inout INT, in INT)

=item B<sub>(inout NUM, in NUM)

=item B<sub>(inout PMC, in INT)

=item B<sub>(inout PMC, in NUM)

=item B<sub>(inout PMC, in PMC)

Decrease $1 by the amount in $2.

=item B<sub>(out INT, in INT, in INT)

=item B<sub>(out NUM, in NUM, in NUM)

=item B<sub>(out PMC, in PMC, in INT)

=item B<sub>(out PMC, in PMC, in PMC)

Set $1 to $2 minus $3.


=cut

=back


=cut

=head2 String operations

These operations operate on STRINGs.

=over 4


=cut

=item B<chopn>(inout STR, in INT)

=item B<chopn>(out STR, in STR, in INT)

Remove $2 characters from the end of the string in $1.  The 3-arg version
removes $3 characters from the end of the string in $2 and returns the result
in $1


=cut

=item B<concat>(inout STR, in STR)

=item B<concat>(out STR, in STR, in STR)

=item B<concat>(out PMC, in PMC, in PMC)

Append the string in $2 to the string in $1.

The three argument version appends the string $3 to $2 and places the result
into $1.


=cut

=item B<repeat>(out STR, in STR, in INT)

=item B<repeat>(out PMC, in PMC, in PMC)

Repeats string $2 $3 times and stores result in $1.


=cut

=item B<length>(out INT, in STR)

Set $1 to the length (in characters) of the string in $2.


=cut

=item B<substr>(out STR, in STR, in INT, in INT)

=item B<substr>(out STR, in STR, in INT, in INT, in STR)

=item B<substr>(inout STR, in INT, in INT, in STR)

Set $1 to the portion of $2 starting at (zero-based) character position
$3 and having length $4.

Optionally pass in string $5 for replacement. If the length of $5 is
different from the length specified in $4, then $2 will grow or shrink
accordingly. If $3 is one character position larger than the length of
$2, then $5 is appended to $2 (and the empty string is returned);
this is essentially the same as

  concat $2, $5

Finally, if $3 is negative, then it is taken to count backwards from
the end of the string (ie an offset of -1 corresponds to the last
character).

The third form is optimized for replace only, ignoring the replaced
substring and does not waste a register to do the string replace.


=cut


=cut

=item B<index>(out INT, in STR, in STR)

=item B<index>(out INT, in STR, in STR, in INT)

The index function searches for one string within
another, but without the wildcard-like behavior of
a full regular-expression pattern match.  It
returns the position of the first occurrence of
$3 in $2 at or after $4.  If $4 is omitted, starts 
searching from the beginning of the string.  
The return value is based at "0".
If the substring is not found, returns "-1".


=cut


=cut

=item B<pack>(inout STR, in INT, in INT)

=item B<pack>(inout STR, in INT, in NUM)

=item B<pack>(inout STR, in INT, in STR)

=item B<pack>(inout STR, in INT, in INT, in INT)

=item B<pack>(inout STR, in INT, in NUM, in INT)

=item B<pack>(inout STR, in INT, in STR, in INT)

Concat $2 bytes from $3 at the end of $1 or replace them at $4 if provided.

BE AFRAID, THIS IS A QUICK HACK, USE IT AT YOUR OWN RISK.


=cut

=back


=cut

=head2 Transcendental mathematical operations

These operations perform various transcendental operations such as logarithmics
and trigonometrics.

=over 4


=cut

=item B<acos>(out NUM, in INT)

=item B<acos>(out NUM, in NUM)

Set $1 to the arc cosine (in radians) of $2.


=cut

=item B<asec>(out NUM, in INT)

=item B<asec>(out NUM, in NUM)

Set $1 to the arc secant (in radians) of $2.


=cut

=item B<asin>(out NUM, in INT)

=item B<asin>(out NUM, in NUM)

Set $1 to the arc sine (in radians) of $2.


=cut

=item B<atan>(out NUM, in INT)

=item B<atan>(out NUM, in NUM)

=item B<atan>(out NUM, in INT, in INT)

=item B<atan>(out NUM, in INT, in NUM)

=item B<atan>(out NUM, in NUM, in INT)

=item B<atan>(out NUM, in NUM, in NUM)

The two-argument versions set $1 to the arc tangent (in radians) of $2.

The three-argument versions set $1 to the arc tangent (in radians) of
$2 / $3, taking account of the signs of the arguments in determining the
quadrant of the result.


=cut

=item B<cos>(out NUM, in INT)

=item B<cos>(out NUM, in NUM)

Set $1 to the cosine of $2 (given in radians).


=cut

=item B<cosh>(out NUM, in INT)

=item B<cosh>(out NUM, in NUM)

Set $1 to the hyperbolic cosine of $2 (given in radians).


=cut

=item B<exp>(out NUM, in INT)

=item B<exp>(out NUM, in NUM)

Set $1 to I<e> raised to the power $2. I<e> is the base of the natural logarithm.


=cut

=item B<ln>(out NUM, in INT)

=item B<ln>(out NUM, in NUM)

Set $1 to the natural (base I<e>) logarithm of $2.


=cut

=item B<log10>(out NUM, in INT)

=item B<log10>(out NUM, in NUM)

Set $1 to the base 10 logarithm of $2.


=cut

=item B<log2>(out NUM, in INT)

=item B<log2>(out NUM, in NUM)

Set $1 to the base 2 logarithm of $2.


=cut

=item B<sec>(out NUM, in INT)

=item B<sec>(out NUM, in NUM)

Set $1 to the secant of $2 (given in radians).


=cut

=item B<sech>(out NUM, in INT)

=item B<sech>(out NUM, in NUM)

Set $1 to the hyperbolic secant of $2 (given in radians).


=cut

=item B<sin>(out NUM, in INT)

=item B<sin>(out NUM, in NUM)

Set $1 to the sine of $2 (given in radians).


=cut

=item B<sinh>(out NUM, in INT)

=item B<sinh>(out NUM, in NUM)

Set $1 to the hyperbolic sine of $2 (given in radians).


=cut

=item B<tan>(out NUM, in INT)

=item B<tan>(out NUM, in NUM)

Set $1 to the tangent of $2 (given in radians).


=cut

=item B<tanh>(out NUM, in INT)

=item B<tanh>(out NUM, in NUM)

Set $1 to the hyperbolic tangent of $2 (given in radians).


=cut

=back


=cut

=head2 Bitwise logical operations

These operations apply  bitwise logical functions to their arguments.

=over 4


=cut

=item B<band>(inout INT, in INT)

=item B<band>(inout PMC, in INT)

=item B<band>(inout PMC, in PMC)

Set the bits of $1 according to the B<and> of the corresponding bits from $1 and $2.

=item B<band>(out INT, in INT, in INT)

=item B<band>(out PMC, in PMC, in INT)

=item B<band>(out PMC, in PMC, in PMC)

Set the bits of $1 according to the B<and> of the corresponding bits from $2 and $3.


=cut

=item B<bnot>(out INT, in INT)

=item B<bnot>(out PMC, in PMC)

Set the bits of $1 to the B<not> of the corresponding bits from $2.


=cut

=item B<bor>(inout INT, in INT)

=item B<bor>(inout PMC, in INT)

=item B<bor>(inout PMC, in PMC)

Set the bits of $1 according to the B<or> of the corresponding bits from $1 and $2.

=item B<bor>(out INT, in INT, in INT)

=item B<bor>(out PMC, in PMC, in INT)

=item B<bor>(out PMC, in PMC, in PMC)

Set the bits of $1 according to the B<or> of the corresponding bits from $2 and $3.


=cut

=item B<shl>(out INT, in INT, in INT)

=item B<shl>(out PMC, in PMC, in PMC)

Set $1 to the value of $2 shifted left by $3 bits.


=cut

=item B<shr>(out INT, in INT, in INT)

=item B<shr>(out PMC, in PMC, in PMC)

Set $1 to the value of $2 shifted right by $3 bits.


=cut

=item B<bxor>(inout INT, in INT)

=item B<bxor>(inout PMC, in INT)

=item B<bxor>(inout PMC, in PMC)

Set the bits of $1 according to the B<xor> of the corresponding bits from $1 and $2.

=item B<bxor>(out INT, in INT, in INT)

=item B<bxor>(out PMC, in PMC, in INT)

=item B<bxor>(out PMC, in PMC, in PMC)

Set the bits of $1 according to the B<xor> of the corresponding bits from $2 and $3.


=cut

=back


=cut

=head2 Logical operations

These operations apply logical functions to their arguments.

=over 4


=cut

=item B<and>(out INT, in INT, in INT)

=item B<and>(out PMC, in PMC, in PMC)

Short-circuiting logical and.  Returns $2 if it's false, else returns $3.


=cut

=item B<not>(out INT, in INT)

=item B<not>(out PMC, in PMC)

Set the boolean state of $1 to the opposite of the boolean state from $2.


=cut

=item B<or>(out INT, in INT, in INT)

=item B<or>(out PMC, in PMC, in PMC)

Short-circuiting logical or.  Returns $2 if it's true, else returns $3.


=cut

=item B<xor>(out INT, in INT, in INT)

=item B<xor>(out PMC, in PMC, in PMC)

Logical xor.  Returns $2 if it's true and $3 isn't,
returns $3 if it's true and $2 isn't, else returns false.


=cut


=cut

=item B<defined>(out INT, in PMC)

Test for PMC definedness.


=cut

=back


=cut

=head2 Interpreter flag modification operations

These operations modify the internal interpreter flags, affecting its
subsequent operation.

=over 4


=cut

=item B<debug>(in INT)

If $1 is zero, turn off debugging. Otherwise turn it on.


=cut

=item B<bounds>(in INT)

If $1 is zero, turn off byte code bounds checking. Otherwise turn it on.


=cut

=item B<profile>(in INT)

If $1 is zero, turn off profiling. Otherwise turn it on.


=cut

=item B<trace>(in INT)

If $1 is zero, turn off tracing. Otherwise turn it on.


=cut

=back


=cut

=head2 Register operations

These operations effect entire sets of registers.

=over 4


=cut

=item B<cleari>()

=item B<clearn>()

=item B<clearp>()

=item B<clears>()

Clear all the registers of the type indicated in the name of the operation.

INTVAL ('i') and FLOATVAL ('n') registers clear to zero.

PMC ('p') and STRING ('s') registers clear to NULL.


=cut

=item B<popi>()

=item B<popn>()

=item B<popp>()

=item B<pops>()

Restore all the registers of the type indicated in the name of the operation
from the most recently B<push>ed copies.


=cut

=item B<pushi>()

=item B<pushn>()

=item B<pushp>()

=item B<pushs>()

Save all the registers of the type indicated in the name of the operation.


=cut

=back


=cut

=head2 Register stack operations

These operations affect individual registers.

=over 4


=cut

=item B<entrytype>(out INT, in INT)

Gets the type of entry $2 of the user stack and puts it in $1.


=cut

=item B<depth>(out INT)

Puts the depth of the user stack in $1.


=cut

=item B<lookback>(out INT, in INT)

=item B<lookback>(out STR, in INT)

=item B<lookback>(out NUM, in INT)

=item B<lookback>(out PMC, in INT)

Finds the entry in the user stack at offset $2 from the top and put it
in register $1. Positive numbers count down from the top of the stack,
negative numbers count up from the bottom. (0 is the topmost entry, -1
is the bottom-most)


=cut

=item B<save>(in INT)

=item B<save>(in NUM)

=item B<save>(in STR)

=item B<save>(in PMC)

Save register or constant $1 onto the user stack.


=cut

=item B<savec>(in STR)

=item B<savec>(in PMC)

Save a clone of register or constant $1 onto the user stack.


=cut

=item B<restore>(out INT)

=item B<restore>(out NUM)

=item B<restore>(out PMC)

=item B<restore>(out STR)

Restore register $1 from the user stack.


=cut

=item B<rotate_up>(in INT)

Rotate the top $1 entries in the user stack by one. If $1 is positive,
then the stack rotates upwards: the ($1)th entry becomes the ($1-1)th
entry and so on, all the way up to the top of the stack, while the
entry formerly at the top of the stack becomes the new ($1)th entry.
If $1 is negative, the stack rotates downwards: the top entry becomes
the second entry, the second becomes the third etc., while the former
($1)th entry becomes the new top entry.


=cut

=item B<intsave>(in INT)

Save register or constant $1 onto the high-speed int stack.


=cut

=item B<intrestore>(out INT)

Restore register $1 from the high-speed int stack.


=cut

=item B<intdepth>(out INT)

Puts the depth of the high-speed int stack in $1.


=cut

=back


=cut

=item B<saveall>()

Save all the registers.

=item B<restoreall>()

Restore all the registers.


=cut

=back


=cut

=head2 Control flow

The control flow opcodes check conditions and manage program flow.

=over 4


=cut

=item B<branch>(in INT)

Branch forward or backward by the amount in $1.


=cut

=item B<bsr>(in INT)

Branch to the location specified by $1. Push the current location onto the call
stack for later returning.


=cut

=item B<jsr>(in INT)

Jump to the location specified by register $1. Push the current
location onto the call stack for later returning.


=cut

=item B<jump>(in INT)

Jump to the address held in register $1.


=cut

=back


=cut

=head2 Symbol table ops

Ops to manipulate the symbol table

=over 4


=cut

=item B<store_global>(in PMC, in STR)

Store global $1 as global symbol $2

=item B<find_global>(out PMC, in STR)

Find the global named $2 and store it in $1


=cut

=back


=cut

=head2 Miscellaneous

Opcodes which need to be sorted into better categories.

=over 4


=cut

=item B<sweep>()

Trigger a dead object detection (DOD) sweep.


=cut

=item B<collect>()

Trigger a garbage collection.


=cut

=item B<sweepoff>()

Disable DOD sweeps. (Nestable)


=cut

=item B<sweepon>()

Re-enable DOD sweeps.


=cut

=item B<collectoff>()

Disable GC runs (nestable).


=cut

=item B<collecton>()

Re-enable GC.


=cut

=item B<interpinfo>(out INT, in INT)

Fetch some piece of information about the interpreter and put it in $1.
Possible values for $2 are:

=over 4

=item 1 The total amount of allocatable memory allocated. This figure
does not include memory used for headers or for the interpreter's internal
structures.

=item 2 The number of dead object detection runs performed.

=item 3 The number of garbage collection runs performed.

=item 4 The number of active PMCs.

=item 5 The number of active buffers.

=item 6 The total number of PMCs allocated.

=item 7 The total number of buffers allocated.

=item 8 The number of headers (PMC or buffer) that have been allocated
since the last DOD run.

=item 9 The amount of memory allocated since the last GC run.

=item 10 The total amount of memory copied during garbage collections.

=back


=cut

=item B<stringinfo>(out INT, in STR, in INT)

Extract some information about string $2 and store it in $1.
Possible values for $3 are:

=over 4

=item 1 The location of the string buffer header.

=item 2 The location of the start of the string.

=item 3 The length of the string buffer (in bytes).

=item 4 The flags attached to the string (if any).

=item 5 The amount of the string buffer used (in bytes).

=item 6 The length of the string (in characters).

=back


=cut

=item B<newinterp>(out PMC, in INT)

Create a new interpreter and store it in a PMC.


=cut

=item B<runinterp>(inout PMC, in INT)

Take a built interpreter and run the code starting at offset $2.


=cut

=item B<new>(out PMC, in INT)

=item B<new>(out PMC, in INT, in INT)

Create a new PMC of class $2; look in F<pmc.h> for the base
vtable types. The assembler allows you to specify PMCs by type
name as well as by integer - you should do this for compatibility,
to avoid problems if the base types get reassigned. For example:

  new P0, .PerlScalar

Optionally a size may be passed to the constructor which may or
may not be used by the particular class. For example:

  new P0, .PerlStruct, 64


=cut

=item B<destroy>(in PMC)

Destroy the PMC.


=cut

=item B<typeof>(out STR, in PMC)

=item B<typeof>(out INT, in PMC)

Return the type of PMC in $2.


=cut

=item B<find_type>(out INT, in STR)

Find the PMC type by name.


=cut

=item B<ret>()

Pop the location off the top of the call stack and go there.


=cut

=item B<sleep>(in INT)

Sleep for $1 seconds.


=cut

=item B<setline>(in INT)

Set the line number for which we're currently executing code.


=cut

=item B<getline>(out INT)

Get the current line number.


=cut

=item B<setfile>(in STR)

Set the name of the file for which we're currently executing code.


=cut

=item B<getfile>(out STR)

Get the name of the current file.


=cut

=item B<setpackage>(in STR)

Set the name of the package for which we're currently executing code.


=cut

=item B<getpackage>(out STR)

Get the name of the current package.


=cut

=item B<loadext>(in STR, in STR)

Load in an extension. $1 is the name of the extension library, $2 is the
initialization routine for it.

=item B<loadlib>(in PMC, in STR)

Load a dynamic link library named $2 and store it in $1.

=item B<callnative>(out PMC, in PMC, in STR)

Call a native routine given a library handle.
$2 contains the handle returned from loadlib, $3 is the
unmangled name of the extension API routine.
Warning: This is probably unportable right now since
some systems need pre-pended _ on symbol names,
and potentially others might have to be linked statically.

=item B<callnative>(out PMC, in PMC, in PMC, in STR)

Same as the 3 argument version except that $3 is a PMC
representing an "object." For methods (not static routines)
this would be the this/self pointer.


=cut

=item B<warningson>(in INT)

Turns on warnings categories.  Categories already turned on will 
stay on.  Current categories and the numbers they map to are:

=over 4

=item 1: undef

=item 2: IO

=item -1: all

=back

To turn on multiple categories, OR the category numbers together.


=cut

=item B<warningsoff>(in INT)

Turns off warnings categories.  Categories already turned off will 
stay off.  See the documentation for B<warningson> for category 
numbers.


=cut

=back


=cut

=head1 COPYRIGHT

Copyright (C) 2001 Yet Another Society. All rights reserved.

=head1 LICENSE

This program is free software. It is subject to the same license
as the Parrot interpreter itself.


=cut

