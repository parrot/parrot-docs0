<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
    "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>  
    <HEAD>
        <TITLE>Untitled</TITLE>
        <LINK REL="stylesheet" TYPE="text/css" 
            HREF="../../../resources/perl.css" 
            TITLE="Default CSS2" media="screen">
    </HEAD>
    <BODY> 
        <A NAME="_top"></A>
        <TABLE CELLSPACING="0" WIDTH="730">
            <TR>
                <TD WIDTH="100%" COLSPAN="2" CLASS="BANNER">parrotcode: <SPAN CLASS="title">Untitled</SPAN></TD>
            </TR>
            <TR>
                <TD WIDTH="100%" COLSPAN="2"  ID="NAV" STYLE="border-bottom: 1px solid #191970;">
                    <a href="../../../html/index.html">Contents</a> | <a href="../../../html/languages.html">Language Implementations</a> | <a href="../../../html/tcl.html">TCL</a>
                </TD>
            </TR>
        </TABLE>
        <DIV CLASS="pod">

<h1><a name="Plan_of_Attack"
>Plan of Attack <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Why do we still have tcl.imc_template?
should be generating tcllib.imc,
not tcl.imc.</p>

<p>clean up expr so that it&#39;s not passing around type indicators.
&#45; just use PMCs everywhere.
This should speed us up quite a bit,
as it will reduce the need for an Array PMC for every operand.</p>

<p>tail call optimizations &#45; there are several cases where I could use this and save myself a call.
Possible to do right now with PASM &#45; wait for PIR support before welding in.</p>

<p>Freeze/Thaw of TclWord would allow us to build a braindead compile option &#45; given a chunk of tcl,
generate a chunk of PIR that we can emit to be saved,
compiled,
and then run again.</p>

<p>Look around and see if we can avoid doing as many substr&#39;s,
particularly in __parse.
(every substring we don&#39;t actually need takes up more resources.
better to just index things until we&#39;re sure we need the substring.</p>

<p>Clean up expr.
MUUUUCH room for improvement there.</p>

<p>provide a way to access existing library PIR from Tcl.</p>

<p>Add benchmarks?</p>

<blockquote>
<p>When converting to Tcl*,
be sure to take advantage of morphing.
Right now,
we&#39;re kind of avoiding morphing.
(like,
having separate new PerlInt and PerlString conditionally depending on the code path.) (fixed in string)</p>

<p>Dynamic Tcl PMCs,
build,
switch.</p>

<p>Ok.
First,
we need to build the dyn pmcs using the new build &#34;group&#34; tag.</p>

<p>Then,
we need to go through and eliminate all references to Perl: (This is done for PerlInt,
PerlString.
Get rid of PerlHash,
PerlArray)</p>

<p>We need to also make sure that we /take/ any PMC and try to do the right thing.
Don&#39;t /require/ that someone pass in a TclString when a PerlString will work fine,
thanks.</p>

<p>implement [list]</p>

<p>This should now be blindingly simple,
given an actual TclList PMC.</p>
</blockquote>

<h1><a name="TODO_(big_pile)"
>TODO (big pile) <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<dl>
<dt><a name="given_freeze/thaw_for_objects..."
>given freeze/thaw for objects...</a></dt><p class="pad"></p>

<dd>Once freeze/thaw is working for tclwords (currently waiting on parrot support),
rewrite proc to preparse once and cache the result in the generated sub rather than reparsing each time.</dd><p class="pad"></p>

<dd>(Though this seems evil,
too.
There must be a better way.)</dd><p class="pad"></p>

<dt><a name="upvar,_uplevel"
>upvar,
uplevel</a></dt><p class="pad"></p>

<dd>set a global lexical level &#45; normally inc&#39;d whenever a UDF proc is called,
dec&#39;d whenever a UDF is exited.</dd><p class="pad"></p>

<dd>Then,
anything that set/get&#39;s a lexical should do so from the global level that we&#39;re using.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>        uplevel ?level? arg ?arg ...?
        upvar ?level? otherVar myVar ?otherVar myVar ...?</pre>

<dd>How do we do this and play nice with other languages? I don&#39;t think we can.</dd><p class="pad"></p>

<dd>Language interoperability can presumably be dealt with after we&#39;ve a language.</dd><p class="pad"></p>

<dt><a name="TclWord"
>TclWord</a></dt><p class="pad"></p>

<dd>implement <code lang='und' xml:lang='und'>is_const</code> to allow for some optimizations in the compiler. when adding words, default to true, but if at any point we add a variable or a command, invalidate that. (mostly done!)</dd><p class="pad"></p>

<dd>Move TclWord namespace into _Tcl::Word, less clutter?</dd><p class="pad"></p>

<dt><a name="(LOW)_varnames"
>(LOW) varnames</a></dt><p class="pad"></p>

<dd>Bitten by overuse of generic IMC vars like $I0 &#45; should reduce their usage as much as possible to simplify upkeep.</dd><p class="pad"></p>

<dt><a name="[[list]]_proc"
>[[list]] proc</a></dt><p class="pad"></p>

<dd>doesn&#39;t handle varargs.</dd><p class="pad"></p>

<dd>support default values (e.g.: proc joe {{drink coffee}} { slurp $drink } )</dd><p class="pad"></p>

<dt><a name="compiler_vs._interpreter"
>compiler vs. interpreter</a></dt><p class="pad"></p>

<dd>it should be possible to further extend our interpreter this to make an actual compiler, where the _compiler emits PIR. So, the resulting call from, say, [source] would be:</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>        # Note this a change from _parse&#39;s current signature 
        (parsed_data_structure,tcl_status,error) = _parse(tcl_code)
        (pir_code,tcl_status,error) = _compile(parsed_data_structure)</pre>

<dd>And now that we have the pir_code, we can either emit the necessary PIR (ala parrot&#39;s &#45;o option) or we can compile and run it.</dd><p class="pad"></p>

<dd>Caveat: how to support &#45;o with user defined procs &#45; right now, proc is defining the sub on the fly, where, with a compiler, we may want to defer compilation, and simply be able to extract the generated PIR.</dd><p class="pad"></p>

<dt><a name="(LOW)_speed"
>(LOW) speed</a></dt><p class="pad"></p>

<dd>Comparing examples/fact.tcl with parrot vs. tclsh (OSX)</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'> ??/??/??: 8&#45;12 x slower, single call
 05/14/04: 500 calls in a loop slows us down to 60x!</pre>

<dt><a name="Tests"
>Tests</a></dt><p class="pad"></p>

<dd>Any future tests, write more like t/tcl_var_subst.t. Eventually cleanup tests so they&#39;re consistent.</dd><p class="pad"></p>

<dt><a name="Add_tests_for..."
>Add tests for...</a></dt><p class="pad"></p>

<dd>tclword, [concat], [join]</dd><p class="pad"></p>

<dt><a name="_"
></a></dt><p class="pad"></p>

<dd>update docs/* &#45; with the parser/interpreter split, things are different. (And, hopefully, easier.)</dd><p class="pad"></p>

<dt><a name="TCL_Pmcs"
>TCL Pmcs</a></dt><p class="pad"></p>

<dd>Then, we can simplify anything that is dealing with numbers to just pass around the Numbers.</dd><p class="pad"></p>

<dd>Then, we need to verify that things like [expr 2a + 2b] fail to produce 4. (That is, Tcl is pickier about numifying than Perl)</dd><p class="pad"></p>

<dt><a name="Dynamic_PMCs"
>Dynamic PMCs</a></dt><p class="pad"></p>

<dd>get new TCL pmcs to work dynamically, not just statically. This is actually a big PITA, because of the inter&#45;related PMCs.</dd><p class="pad"></p>

<dd>(write tests for them)</dd><p class="pad"></p>

<dt><a name="test_suite_patches"
>test suite patches</a></dt><p class="pad"></p>

<dd>need to patch testall so that it&#39;s not so cranky about people who don&#39;t play nice with the new tests...</dd><p class="pad"></p>

<dt><a name="Tcl_PMCs"
>Tcl PMCs</a></dt><p class="pad"></p>

<dd>NB: All this code was backed out (of tcl.imc, the dynclasses are still checked in) because of the issues with DYN Tcl PMCS!</dd><p class="pad"></p>

<dd>TclLists now correctly promote natives to their respective types. Now, fix TclArrays to do the same. (look for references to undef(), replace with pmc_new(interp,enum_class_TclString) &#45; we&#39;ll use the TclString in the same way they use undef, to auto&#45;morph to the right value. Lazy, but effective.</dd><p class="pad"></p>

<dd>Find the bits of code where we were specifically creating a TclString before inserting it into a TclList, and remove them &#45; should be able to just add the string and have it JFW at this point.</dd><p class="pad"></p>

<dt><a name="TCL_Object"
>TCL_Object</a></dt><p class="pad"></p>

<dd>To simplfy the conversion code, We&#39;re going to pass around tcl_object pmc&#39;s instead of strings, both as return values from procedures and builtins, and pass them in to the strings as well. This will let us get rid of all the conversion code that&#39;s everywhere, and just DTRT.</dd><p class="pad"></p>

<dd>For now, get working with our current repetoire, strings, arrays, and ints. Once we have arrays working in this method, adding in lists <i>should</i> be a piece of cake. beg borrow and steal from the PerlScalar implementation, as that does much the same thing we need to.</dd><p class="pad"></p>

<dd>Ok. Strings, Ints and Floats should inter_convert without a problem. There are Arrays and Lists also, which are NOT part of the TclObject Hierarchy. Lists still don&#39;t autoconvert to strings, though they should not sure how to autoconvert a string to a list... perhaps it should happen automatically on keyed access (which right now does a substr)</dd><p class="pad"></p>

<dd>Ok. All references to any Perl types (other than PerlUndef, which bears investigation before we rip it out. &#45; Probably used mainly on hash lookups &#45; should ditch it and go with &#34;return NULL;&#34; in the pmcdef, and then use isnull rather than our current PerlUndef check in IMC)</dd><p class="pad"></p>

<dd>Now, go through all the commands, ops, and functions to cleanup how we handle these objects &#45; remember that TclList and TclArray are NOT currently descended from tclobject, and this may bollux some things up.</dd><p class="pad"></p>

<dt><a name="SArray_vs._PerlArray/TclList"
>SArray vs. PerlArray/TclList</a></dt><p class="pad"></p>

<dd>investigate using SArray vs. TclList for speed. (many times we don&#39;t know how many slots we&#39;re going to need ahead of time, though.) &#45; looks like we might be able to use them for the expression stuff that we are passing around.... which, now that we have real Tcl PMCs, can probably go away</dd><p class="pad"></p>

<dd>(most uses of PerlArray are gone, now that we are using foldup)</dd><p class="pad"></p>

<dt><a name="unfinished_commands"
>unfinished commands</a></dt><p class="pad"></p>

<dd>[array set] &#45; written &#45; write tests.</dd><p class="pad"></p>

<dd>[array statistics] &#45; useless?</dd><p class="pad"></p>

<dd>[array anymore], [array donesearch] [array nextelement], [array startsearch] { use iterators }</dd><p class="pad"></p>

<dd>[global]</dd><p class="pad"></p>

<dd>[string repeat], [string replace], [string tolower], [string totitle], [string toupper], [string trim], [string trimleft], [string trimright], [string compare], [string equal], [string last]</dd><p class="pad"></p>

<dd>[string bytelength], [string compare], [sring is], [string map], [string match], [string wordstart], [string wordend]</dd><p class="pad"></p>

<dt><a name="channels"
>channels</a></dt><p class="pad"></p>

<dd>keep track of channels, include stdin, stdout, stderr &#45; keep in a global hash of name to ParrotIO pmcs. Tie in with &#34;puts&#34; and other chanel based commands. (some progress made here.)</dd><p class="pad"></p>

<dt><a name="given_[list]"
>given [list]</a></dt><p class="pad"></p>

<dd>[foreach]</dd><p class="pad"></p>

<dt><a name="given_REs"
>given REs</a></dt><p class="pad"></p>

<dd>&#34;string match&#34; (it&#39;s glob&#45;style, but easy to do given REs)</dd><p class="pad"></p>

<dt><a name="given_[string_match]"
>given [string match]</a></dt><p class="pad"></p>

<dd>The following items require [string match] to be implemented: [array get], [array names], [array unset]</dd><p class="pad"></p>

<dt><a name="given_Unicode"
>given Unicode</a></dt><p class="pad"></p>

<dd>Need unicode support for \u escapes, and for &#34;string wordend&#34;, &#34;string wordstart&#34;, &#34;string is&#34;, &#34;string bytelength&#34;,</dd><p class="pad"></p>

<dd>This now works in parrot, modulo support for actually, oh, printing things out.</dd><p class="pad"></p>

<dt><a name="given_arrays"
>given arrays</a></dt><p class="pad"></p>

<dd>[string map]</dd><p class="pad"></p>

<dt><a name="expr"
>expr</a></dt><p class="pad"></p>

<dd>TBD: big rethunk.</dd><p class="pad"></p>

<dd>TBD: octal, hex. (there&#39;s no way to convert programmatically from an octal or hex string in parrot to a int?)</dd><p class="pad"></p>

<dd>TBD: strings, floats as operaands &#45; (many of the math funcs return floats but you can&#39;t specify them, and not everything takes them (try, for example, [expr sin(1) + sin(1)] vs [expr sin(1) * sin(1)].)</dd><p class="pad"></p>

<dd>TBD: blocks, commands, and strings as operands</dd><p class="pad"></p>

<dd>TBD: logical binary ops &#38; ternary op (need deferred evaluation) ; unary ops; ops that work on strings only.</dd><p class="pad"></p>

<dd>TBD: functions that take &#62; 1 arg.</dd><p class="pad"></p>

<dd>TBD: Argument type requirements &#45; Currently works ONLY on bitand &#45; esp need to get any that require int&#45;only args, as we can now /generate/ floats, even if we cannot specify them.</dd><p class="pad"></p>

<dt><a name="misc"
>misc</a></dt><p class="pad"></p>

<dd>tclsh normally does some extra processing that we aren&#39;t doing, namely .tclshrc/tclshrc.tcl, setting of variables argc, argv, argv0, and tcl_interactive... see also &#34;man n tclvars&#34;</dd><p class="pad"></p>

<dt><a name="misc"
>misc</a></dt><p class="pad"></p>

<dd>interactive tclsh mode currently only waits for EOF and then runs all commands entered. should have sane defaults for tcl_prompt1, tcl_prompt2 and respect them, and process intermediate input.</dd><p class="pad"></p>

<dt><a name="misc"
>misc</a></dt><p class="pad"></p>

<dd>octal, hex, and unicode escapes are not supported. (Not sure parrot is ready for this yet)</dd><p class="pad"></p>

<dt><a name="tests"
>tests</a></dt><p class="pad"></p>

<dd>run a tcl test suite (7.6p2 ?) and pass one test. (then, pass most of them.) (then, retarget against tcl&#45;latest)</dd><p class="pad"></p>

<dt><a name="misc"
>misc</a></dt><p class="pad"></p>

<dd>(aside &#45; expression needs better error handling support, and perhaps a rethunk on how we&#39;re passing data around &#45; FYI, if we&#39;re going to be using PerlInt, PerlNum, etc, we need to make sure they stringify as tcl expects them to &#45; a PerlNum of 5 &#45;&#62; &#34;5&#34; instead of &#34;5.0&#34;, e.g.)</dd><p class="pad"></p>

<dd>complete [error] (need global var support)</dd><p class="pad"></p>

<dd>If the return type of the outermost script is not OK, return the <i>appropriate</i> code to the system.</dd><p class="pad"></p>

<dt><a name="misc"
>misc</a></dt><p class="pad"></p>

<dd>list variables &#45; stringToList already exists (had to write it for &#34;proc&#34;s argument handling.) &#45; need to write listToString, need to be able to save Lists as variables. &#45; This should now be possible, with the addition of the Tcl* PMCs.</dd><p class="pad"></p>

<dd>Expressions are a bit harder because we need an additional bit of information. (is this an op, an operand, or &#34;a chunk that is yet to be evaluated)</dd><p class="pad"></p>

<dt><a name="missing_procs"
>missing procs</a></dt><p class="pad"></p>

<dd>Here&#39;s a list of commands from the 7.3 Ousterhout book that have yet to be implemented. Just because something is implemented doesn&#39;t mean it&#39;s a full implementation, either. That&#39;s what the test suite is for. =&#45;) I&#39;ve tried to group them so that any procs that depend on another proc to really work are so listed, and that related procs are grouped together. Some are SMOPs at this point, others require me to add features, or refactor. Many already implemented procs will require updating after procs/features are added.</dd><p class="pad"></p>

<pre lang='und' xml:lang='und'>  upvar, uplevel  should be pretty easy with the lexical pad
    support in parrot. Well, upvar, anyway. implementing uplevel
    may require a rethunk. 

  foreach  {list}

  switch  {regexp regsub &#34;string match&#34;}

  list {llength, linsert, lreplace, lrange, lappend,
          lsearch, lsort, split}

  cd, file, pwd, pid, glob

  seek, tell, open, close, eof, flush, read, gets

  open close

  scan {list}

  info, exec {use exec/spawn opcodes.}

  auto_mkindex*, trace*

  unknown, history [ only in interactive mode ]

  regexp, regsub
 
  * isn&#39;t a recent distro of tcl
  
  And, here are more from a more recent tcl in no order.

  after bgerror binary case clock dde
  encoding fblocked fconfigure fcopy fileevent filename
  http interp {setup our current single interp as an object?}
  library lindex load lset memory
  msgcat namespace package packagens
  pkgMkIndex re_syntax registry resource
  safe socket subst tcltest
  update variable vwait
 
  also see &#34;man n tclvars&#34;</pre>

<dt><a name="tests"
>tests</a></dt><p class="pad"></p>

<dd>Long term goal: Run the tcl test suite. Will an older one, be easier to pass? Yes, much easier. We still have a ways to go, however. To run all the tests, run tclsh, sourcing &#34;&#60;tcl distro&#62;tests/all&#34;.</dd><p class="pad"></p>

<dd>The sooner we can do this, the better, as I only want to have tests for internals, not for any Tcl.</dd><p class="pad"></p>

<dt><a name="7.6_test_suite"
>7.6 test suite</a></dt><p class="pad"></p>

<dd>missing quite a bit to be able to think about running this, notably:</dd><p class="pad"></p>

<dd>from all:</dd><p class="pad"></p>

<dd>[foreach], [lsort], [glob], [string match], [puts stdout], catch</dd><p class="pad"></p>

<dd>from incr, one of the (easier?) tests to pass:</dd><p class="pad"></p>

<dd>[string compare], list, source, info, trace {is this still in tcl 8?}, concat</dd><p class="pad"></p>

<dd>which calls &#34;def&#34;, which uses:</dd><p class="pad"></p>

<dd>$tcl_platform, [info exists] , [info commands], unset, array vars, open, global, uplevel (GAH), regsub (GAH), fconfigure (GAH), file (GAH) exec (GAH)</dd><p class="pad"></p>

<dt><a name="test_commands"
>test commands</a></dt><p class="pad"></p>

<dd>cmd_expr should check prededence, parens, etc, as well as all the defined ops and functions.</dd><p class="pad"></p>

<dt><a name="test_macros?"
>test macros?</a></dt><p class="pad"></p>

<pre lang='und' xml:lang='und'>        is_space</pre>
</dl>

<h1><a name="POD_ERRORS"
>POD ERRORS <a href='#_top'><img alt='^' border=0 src='../../../resources/up.gif'></a></a></h1>

<p>Hey! <b>The above document had some coding errors, which are explained below:</b></p>

<dl>
<dt><a name="Around_line_29:"
>Around line 29:</a></dt><p class="pad"></p>

<dd>You can&#39;t have =items (as at line 35) unless the first thing after the =over is an =item</dd><p class="pad"></p>

<dt><a name="Around_line_50:"
>Around line 50:</a></dt><p class="pad"></p>

<dd>You forgot a &#39;=back&#39; before &#39;=head1&#39;</dd><p class="pad"></p>

<dt><a name="Around_line_414:"
>Around line 414:</a></dt><p class="pad"></p>

<dd>=back doesn&#39;t take any parameters, but you said =back 4</dd><p class="pad"></p>
</dl>
        </DIV>
        <P>
        <TABLE BORDER="0" WIDTH="730" CELLSPACING="0" CELLPADDING="0">
            <TR ALIGN="RIGHT">
                <TD WIDTH="590" VALIGN="MIDDLE">
                    <BR>
                    <DIV CLASS="FOOTER">
                        <DIV ALIGN="LEFT">
                        </DIV>
                    </DIV>
                </TD>
                <TD VALIGN="middle" ALIGN="center">
                    <IMG BORDER=0
                        SRC="../../../resources/parrot.small.png" 
                        ALT="parrot">
                </TD>
            </TR>
        </TABLE>
    </BODY>
</HTML>
